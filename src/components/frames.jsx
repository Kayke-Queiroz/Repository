import { useState, useEffect, useRef } from 'react';
import { useLanguage } from '../context/LanguageContext';

const SCROLL_HEIGHT_MULTIPLIER = 2; // 200vh
const END_THRESHOLD = 0.99;
const STICKY_EXTRA_RANGE = 0.005; // 0.5% a mais depois do 99%
const RESET_BELOW = 0.8; // se voltar muito, reseta o "travamento" final

const Frames = () => {
  const canvasRef = useRef(null);
  const [frames, setFrames] = useState([]);
  const [scrollPercent, setScrollPercent] = useState(0);
  const [hasReachedEnd, setHasReachedEnd] = useState(false);
  const [isScrollLocked, setIsScrollLocked] = useState(false);
  const [lockScrollY, setLockScrollY] = useState(0);
  const [imagesLoaded, setImagesLoaded] = useState(false);
  const { t } = useLanguage();

  const TOTAL_FRAMES = 168; // Total amount of frames in the spritesheet
  const COLS = 14;          // As generated by our script
  const ROWS = Math.ceil(TOTAL_FRAMES / COLS);

  // ===============================
  // CARREGAMENTO DA SPRITE SHEET
  // ===============================
  useEffect(() => {
    const loadSprite = async () => {
      try {
        // Resolve a Imagem única do Webpack/Vite
        const spriteModule = await import('../assets/videos/frames_sprite.jpg');
        const spriteUrl = spriteModule.default;

        const img = new Image();
        img.src = spriteUrl;

        // Use img.decode() to parse the image asynchronously off the main-thread
        // This prevents the massive TBT (Total Blocking Time) spike on Lighthouse
        await img.decode();

        setFrames([img]);
        setImagesLoaded(true);
      } catch (err) {
        console.error("Failed to load spritesheet", err);
      }
    };

    loadSprite();
  }, []);

  // ===============================
  // NATIVE SCROLL CONTROLLER
  // ===============================
  useEffect(() => {
    let ticking = false;

    const onScroll = () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          const totalScrollHeight = SCROLL_HEIGHT_MULTIPLIER * window.innerHeight;
          const scrollTop = window.scrollY;

          // enquanto estiver travado, mantém a posição e não atualiza animação
          if (isScrollLocked) {
            window.scrollTo({ top: lockScrollY, behavior: 'instant' });
            ticking = false;
            return;
          }

          const rawPercent = Math.min(1, Math.max(0, scrollTop / totalScrollHeight));

          const wasAtEnd = hasReachedEnd;
          let nextHasReachedEnd = hasReachedEnd;

          // se o usuário voltar bastante, libera para repetir a animação
          if (nextHasReachedEnd && rawPercent < RESET_BELOW) {
            nextHasReachedEnd = false;
          }

          // se ainda não tinha chegado no fim e agora passou do threshold, arma o "travamento"
          const becomingEndNow = !nextHasReachedEnd && rawPercent >= END_THRESHOLD;

          if (becomingEndNow) {
            nextHasReachedEnd = true;

            // Verifica se o usuário clicou num link do Navbar para pular a animação
            const isBypassing = sessionStorage.getItem('skipFramesLock') === 'true';

            if (isBypassing) {
              sessionStorage.removeItem('skipFramesLock');
            } else {
              // trava o scroll por ~1s na posição atual normalmente
              setIsScrollLocked(true);
              setLockScrollY(scrollTop);
              setTimeout(() => {
                setIsScrollLocked(false);
              }, 1000);
            }
          }

          if (nextHasReachedEnd !== hasReachedEnd) {
            setHasReachedEnd(nextHasReachedEnd);
          }

          const stickyEnd = END_THRESHOLD + STICKY_EXTRA_RANGE;
          // só podemos "sair" depois de já ter travado antes (wasAtEnd)
          const canFinish = wasAtEnd && rawPercent >= stickyEnd;

          let effectivePercent;

          if (!nextHasReachedEnd) {
            // ainda na animação normal
            effectivePercent = rawPercent;
          } else if (!canFinish) {
            // chegou no fim, mas ainda não liberou para sair -> trava no último frame
            effectivePercent = END_THRESHOLD;
          } else {
            // já estava travado e o usuário continuou descendo -> libera para sair
            effectivePercent = rawPercent;
          }

          setScrollPercent(effectivePercent);
          ticking = false;
        });
        ticking = true;
      }
    };

    window.addEventListener('scroll', onScroll, { passive: true });

    // Trigger on mount and resize
    onScroll();

    return () => {
      window.removeEventListener('scroll', onScroll);
    };
  }, [hasReachedEnd, isScrollLocked, lockScrollY]);

  // ===============================
  // CANVAS RENDERER (CROP SPRITE)
  // ===============================
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || frames.length === 0) return;

    const ctx = canvas.getContext('2d');
    const spriteSheet = frames[0];

    // Calcula em qual frame estamos Baseado nos 168 (0 a 167)
    const frameIndex = scrollPercent >= END_THRESHOLD
      ? TOTAL_FRAMES - 1
      : Math.floor(scrollPercent * (TOTAL_FRAMES - 1));

    // Descobre as dimensões de cada corte lá dentro do Sprite original
    const frameWidth = spriteSheet.width / COLS;
    const frameHeight = spriteSheet.height / ROWS;

    // Achar o eixo X e Y deste corte lá dentro da cartela gigante
    const col = frameIndex % COLS;
    const row = Math.floor(frameIndex / COLS);
    const sX = col * frameWidth;
    const sY = row * frameHeight;

    const cw = canvas.width;
    const ch = canvas.height;

    // Lógica para manter a Proporção (Cover) da tela pro Canvas assim como antes
    const ratio = Math.max(cw / frameWidth, ch / frameHeight);
    const nw = frameWidth * ratio;
    const nh = frameHeight * ratio;
    const cx = (cw - nw) / 2;
    const cy = (ch - nh) / 2;

    ctx.clearRect(0, 0, cw, ch);
    // ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
    ctx.drawImage(spriteSheet, sX, sY, frameWidth, frameHeight, cx, cy, nw, nh);

  }, [frames, scrollPercent]);

  // Resize handler for canvas
  useEffect(() => {
    const handleResize = () => {
      if (canvasRef.current) {
        canvasRef.current.width = window.innerWidth;
        canvasRef.current.height = window.innerHeight;
      }
    };
    window.addEventListener('resize', handleResize);
    handleResize();
    return () => window.removeEventListener('resize', handleResize);
  }, []);


  const stickyEnd = END_THRESHOLD + STICKY_EXTRA_RANGE;
  const isEnd = hasReachedEnd && scrollPercent >= stickyEnd && !isScrollLocked;

  return (
    <>
      {/* ===============================
          FRAME FIXO (ANIMAÇÃO)
      =============================== */}
      <div
        className={`fixed top-0 left-0 w-full h-[100dvh] bg-black transition-opacity duration-300 z-overlay
          ${isEnd ? 'opacity-0 pointer-events-none' : 'opacity-100'}
          ${scrollPercent === 0 ? 'pointer-events-none' : ''}
        `}
      >
        <canvas
          ref={canvasRef}
          className="w-full h-full block"
        />
        {/* Loading text removed as per request (first frame is shown instead) */}
      </div>

      {/* ===============================
          SCROLL / PLACEHOLDER
      =============================== */}
      <div style={{ height: '200vh' }}>
        {/* Último frame "congelado" via canvas se precisar, ou apenas espaço vazio */}
        <div className="h-[100dvh] w-full">
        </div>
        {/* ===============================
            CONTEÚDO DO SITE
        =============================== */}
      </div>

    </>
  );
};

export default Frames;
